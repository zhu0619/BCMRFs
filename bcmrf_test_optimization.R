
# This script show an example of SCL prediction using BCMRFs algorithm
# Author : Lu Zhu
# Email : lzhu@techfak.uni-bielefel.de

#---------------------------------------------------------#  
# Load dependencies
#---------------------------------------------------------#
pkg_to_require = c("ROCR","Matrix","brglm","mvtnorm","glmnet","plyr","igraph",'utiml','mygene')
pkg_to_install = setdiff(pkg_to_require, rownames(installed.packages()))
if (length(pkg_to_install) > 0) {
  for(pkg_name in pkg_to_install){
    print(paste0('Installing package ',pkg_name))
    install.packages(pkg_name)
  }
}

for(pkg_name in pkg_to_require){
  print(paste0('requring package ',pkg_name))
  require(pkg_name,character.only = TRUE)
}


source("bcmrfs_module/basic_functions.R")
source('bcmrfs_module/BCMRFs_functions.R')

# turn warning off
options(warn=-1)
# to turn warning back 
# options(warn=0)

#---------------------------------------------------------#
# load PPI networks
#---------------------------------------------------------#

## network preparation
# net_T_file = "test_datasets/phy_ppi_test.gml"
optimization  = function(net_T_file,fout){
  if(file.exists(net_T_file)){  
    # net_T_file = "test_datasets/phy_ppi_test.gml"
    # net_T = read_graph(net_T_file, format = "graphml")
    # option: select the largest subnetwork in case of unconnected graph
    net_T = GiantCluster(read_graph(net_T_file, format = "graphml"))
    
    # A_ori = get.adjacency(net_T, type="both",attr=NULL, names=TRUE, sparse=TRUE)
    # option: weighted network
    wA_ori = get.adjacency(net_T, type="both",attr='weight', names=TRUE, sparse=TRUE)
    wA = as.matrix(wA_ori)
    # remove the self-interacting PPI
    # diag(A_ori)=0
    diag(wA_ori)=0
    
    #---------------------------------------------------------#
    # load the spatial adjacent matrix of subcellular compartments
    # user can customize the matrix for their needs
    #---------------------------------------------------------#
    adjMatrix = adjacentMatrixFile("test_datasets/test_adjMatrix.csv")
    
    #---------------------------------------------------------#
    # load features
    # data can be generated by 'feature_generator module'
    #---------------------------------------------------------#
    # features_ori = read.csv("test_datasets/test_feature.txt",sep="\t",header = T,row.names = 1)
    features_ori = read.csv("test_datasets/features_data/all_no_GO_feature_table.csv",sep=";",header = T,row.names = 1)
    
    # intersection of proteins which have feature data and proteins in the tp-phy graph
    prot = row.names(features_ori)
    A_prot = row.names(wA_ori)
    common = prot[prot %in% A_prot]
    uncommon = A_prot[!A_prot %in% prot]
    features = features_ori[common,]
    if(length(uncommon)>0){
      f = matrix( rep(0,length(uncommon)*ncol(features)),nrow=length(uncommon),ncol = ncol(features),dimnames = list(uncommon,colnames(features)))
      features = rbind(features,f)
    }
    features = features[,colSums(features) != 0  ]
    
    
    
    #---------------------------------------------------------#
    # load available protein scl labels 
    #---------------------------------------------------------#
    # exp = 'test_datasets/test_scl.txt'
    exp = 'test_datasets/scl_data/CMPT_hpa_scl_acc_2018.txt'
    L_real = loadProteinSCL(exp ,wA, '\t')
    
    scls = colnames(L_real)
    cat("Investigated SCLs are \n", scls,"\n")
    
    # the scl labeling of protein 
    nb_label = rowSums(L_real) 
    names(nb_label)=rownames(L_real)
    
    unlabeled = names(which(nb_label == 0));
    labeled = names(which(nb_label > 0));
    
    cat("Number of unlabeled proteins is ",length(unlabeled),"\n")
    cat("Number of labeled proteins is",length(labeled),"\n")
    
    L_all = L_real 
    if(length(unlabeled)>0){
      L_all[unlabeled,] = -1
    }
    
    
    #---------------------------------------------------------#
    # optimization parameters
    #---------------------------------------------------------#
    nb.iter = 300
    pcut = 0.5 # default probability threshold 
    
    # mask labels for evaluation if necessary 
    masked = NULL
    seed = labeled[!labeled %in% masked]
    features = features[,colnames(features)%in%scls]
    
    
    L_all_prob = L_real[,scls]
    
    L_all_plf = L_real[1,]
    cols = rainbow(length(scls))
    names(cols) = scls
    
    adjMatrix = adjMatrix[scls,scls]
    
    
    ini_record=c()
    for(Lname in scls){
      tryCatch({
        cat("SCL:",Lname,"\n")
        iteration = 0
        #----------------------------------------------
        
        L_all[masked,Lname] = -1
        Lsingle = L_all[,Lname];
        
        unknown = unique(c(unlabeled,masked))
        known = seed
        cat("Nb of unknown proteins:",length(unknown),"\n")
        cat("Nb of known proteins",length(known),"\n")
        
        #-----------------------------#     
        #  Initiation 
        #-----------------------------#
        cat("ppi!\n")
        L_initialized = try(BCMRFs_single_imbalance(wA, Lsingle, Lname, nb.iter ,unknown,known, pcut), silent=FALSE);
        L_all[,Lname] = L_initialized$SCL_label
        L_all_prob[,Lname]  =  L_initialized$Probability
        L_all_plf[Lname]  =  L_initialized$Likelihood
        
      }, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
    }
    
    
    L_all_initialized = L_all
    colnames(L_all_initialized ) = scls
    L_all_prob_initialized = L_all_prob
    colnames(L_all_prob_initialized ) = scls
    
    cat("Initialized!")
    
    #-----------------------------------------------#
    # collective iterations
    #-----------------------------------------------#
    temp= 1000
    coolrate = 0.2
    collective.scls = list()
    collective.scls[[1]]=L_all
    
    
    # timer
    start.time <- Sys.time()
    
    nit = 5 # BCMRFs total iteration 
    
    for(iter in 1:nit){
      cat("iteration:",iter,"\n")
      for(Lname in scls){
        result = NULL
        tryCatch({
          cat("SCL:",Lname,"\n")
          Lsingle = L_all[,Lname];
          
          Adjs=names(which(adjMatrix[scls,Lname]==1))
          if(length(Adjs)>1){
            Adjs = Adjs[colSums(L_all[seed,Adjs])>0]
          }else{
            Adjs = Adjs[sum(L_all[seed,Adjs])>0]
          }
          
          if(Lname %in% colnames(features)){
            
            feature = features[names(Lsingle),Lname]
            names(feature) = names(Lsingle)
            
            BMRF_adj_feature_imbalance_tissue_result = try(BMRF_adj_feature_imbalance(wA, Lsingle, Adjs, Lname, nb.iter,feature,L_all,unknown,known, pcut), silent=FALSE);
            result = BMRF_adj_feature_imbalance_tissue_result
          }else{
            BMRF_adj_imbalance_tissue_result = try(BCMRFs_adj_imbalance(wA, Lsingle, Adjs, Lname,nb.iter,L_all, unknown,known, pcut), silent=FALSE);
            result = BMRF_adj_imbalance_tissue_result
          }
          
          if(!is.null(result)){
            logc = L_all_plf[Lname]
            logp = result$Likelihood
            
            if( acceptanceProbability(sum(logc),sum(logp),temp) > runif(1))
            {
              # cat("accept!")
              L_all_prob[,Lname] = round(result$Probability,3)
              L_all[,Lname] = result$SCL_label
              L_all_plf[Lname] = result$Likelihood
            }
            else{
              # cat("reject!")
            }
          }
          
        }, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
      }
      
      print(paste0('iteration: ',iter))
      
      collective.scls[[iter+1]]=L_all
      if(temp>1){
        temp=temp*(1-coolrate)
      }
    }
    
    end.time <- Sys.time()
    time.taken <- end.time - start.time
    print(time.taken)
    f_label = paste0(fout,"_label.txt")
    write.table(L_all,file=f_label)
    f_prob = paste0(fout,"_prob.txt")
    write.table(L_all_prob,file=f_prob)
  }
  else{
    cat("File doesn't exist. Please check your input files!")
  }
}

