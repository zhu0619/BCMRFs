

#---------------------------------------------------------#  
# Load dependencies
#---------------------------------------------------------#
pkg_to_require = c("ROCR","Matrix","brglm","mvtnorm","glmnet","plyr","igraph",'utiml','mygene')
pkg_to_install = setdiff(pkg_to_require, rownames(installed.packages()))
if (length(pkg_to_install) > 0) {
  for(pkg_name in pkg_to_install){
    print(paste0('Installing package ',pkg_name))
    install.packages(pkg_name)
  }
}

for(pkg_name in pkg_to_require){
  print(paste0('requring package ',pkg_name))
  require(pkg_name,character.only = TRUE)
}


source("bcmrfs_module/basic_functions.R")
source('bcmrfs_module/BCMRFs_functions.R')

# turn warning off
options(warn=-1)
# to turn warning back 
# options(warn=0)

#---------------------------------------------------------#
# load PPI networks
#---------------------------------------------------------#

## network preparation
net_T_file = "test_dataset/test.gml"
net_T = read_graph(net_T_file, format = "graphml")
# option: select the largest subnetwork in case of unconnected graph
# net_T = GiantCluster(read_graph(net_T_file, format = "graphml"))

# A_ori = get.adjacency(net_T, type="both",attr=NULL, names=TRUE, sparse=TRUE)
# option: weighted network
wA_ori = get.adjacency(net_T, type="both",attr='weight', names=TRUE, sparse=TRUE)
wA = as.matrix(wA_ori)
# remove the self-interacting PPI
# diag(A_ori)=0
diag(wA_ori)=0

#---------------------------------------------------------#
# load the spatial adjacent matrix of subcellular compartments
# user can customize the matrix for their needs
#---------------------------------------------------------#
adjMatrix = adjacentMatrixFile("test_dataset/test_adjMatrix.csv")

#---------------------------------------------------------#
# load features
# data can be generated by 'feature_generator module'
#---------------------------------------------------------#
features_ori = read.csv("test_dataset/test_feature.txt",sep="\t",header = T,row.names = 1)


# intersection of proteins which have feature data and proteins in the tp-phy graph
prot = row.names(features_ori)
A_prot = row.names(wA_ori)
common = prot[prot %in% A_prot]
uncommon = A_prot[!A_prot %in% prot]
features = features_ori[common,]
if(length(uncommon)>0){
  f = matrix( rep(0,length(uncommon)*ncol(features)),nrow=length(uncommon),ncol = ncol(features),dimnames = list(uncommon,colnames(features)))
  features = rbind(features,f)
}
features = features[,colSums(features) != 0  ]



#---------------------------------------------------------#
# load available protein scl labels 
#---------------------------------------------------------#
exp = 'test_dataset/test_scl.txt'

L_real = loadProteinSCL(exp ,wA, ';')

scls = colnames(L_real)
cat("Investigated SCLs are ", scls,"\n")

# the scl labeling of protein 
nb_label = rowSums(L_real) 
names(nb_label)=rownames(L_real)

unlabeled = names(which(nb_label == 0));
labeled = names(which(nb_label > 0));

cat("Number of unlabeled proteins is ",length(unlabeled),"\n")
cat("Number of labeled proteins is",length(labeled),"\n")

L_all = L_real 
if(length(unlabeled)>0){
  L_all[unlabeled,] = -1
}


#---------------------------------------------------------#
# optimization parameters
#---------------------------------------------------------#
nb.iter = 300
pcut = 0.5

# mask labels for evaluation if necessary 
masked = NULL
seed = labeled[!labeled %in% masked]
features = features_ori[,colnames(features_ori)%in%scls]


L_all_prob = L_real[,scls]

L_all_plf = L_real[1,]
cols = rainbow(length(scls))
names(cols) = scls

adjMatrix = adjMatrix[scls,scls]


ini_record=c()
for(Lname in scls){
  tryCatch({
    cat("SCL:",Lname,"\n")
    iteration = 0
    #----------------------------------------------
    
    L_all[masked,Lname] = -1
    Lsingle = L_all[,Lname];
    
    unknown = unique(c(unlabeled,masked))
    known = seed
    cat("Nb of unknown proteins:",length(unknown),"\n")
    cat("Nb of known proteins",length(known),"\n")
    
    #-----------------------------#     
    #  Initiation 
    #-----------------------------#
    cat("ppi!\n")
    L_initialized = try(BCMRFs_single_imbalance(wA, Lsingle, Lname, nb.iter ,unknown,known), silent=FALSE);
    L_all[,Lname] = L_initialized$SCL_label
    L_all_prob[,Lname]  =  L_initialized$Probability
    L_all_plf[Lname]  =  L_initialized$Likelihood
    
  }, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
}


L_all_initialized = L_all
colnames(L_all_initialized ) = scls
L_all_prob_initialized = L_all_prob
colnames(L_all_prob_initialized ) = scls

cat("Initialized!")

#-----------------------------------------------#
# collective iterations
#-----------------------------------------------#
temp= 1000
coolrate = 0.2
collective.scls = list()
collective.scls[[1]]=L_all


# timer
start.time <- Sys.time()

nit = 5 # BCMRFs total iteration 

for(iter in 1:nit){
  cat("iteration:",iter,"\n")
  for(Lname in scls){
    result = NULL
    tryCatch({
      cat("SCL:",Lname,"\n")
      Lsingle = L_all[,Lname];
      
      Adjs=names(which(adjMatrix[scls,Lname]==1))
      if(length(Adjs)>1){
        Adjs = Adjs[colSums(L_all[seed,Adjs])>0]
      }else{
        Adjs = Adjs[sum(L_all[seed,Adjs])>0]
      }
      
      if(Lname %in% colnames(features)){
        
        feature = features[names(Lsingle),Lname]
        names(feature) = names(Lsingle)
        
        BMRF_adj_feature_imbalance_tissue_result = try(BMRF_adj_feature_imbalance(wA, Lsingle, Adjs,Lname, nb.iter,feature,L_all,unknown,known), silent=FALSE);
        result = BMRF_adj_feature_imbalance_tissue_result
      }else{
        BMRF_adj_imbalance_tissue_result = try(BCMRFs_adj_imbalance(wA, Lsingle, Adjs, Lname,nb.iter,L_all, unknown,known), silent=FALSE);
        result = BMRF_adj_imbalance_tissue_result
      }
      
      if(!is.null(result)){
        logc = L_all_plf[Lname]
        logp = result$Likelihood
        
        if( acceptanceProbability(sum(logc),sum(logp),temp) > runif(1))
        {
          # print("accept!")
          L_all_prob[,Lname] = result$Probability
          L_all[,Lname] = result$SCL_label
          L_all_plf[Lname] = result$Likelihood
        }
        else{
          cat("reject!")
        }
      }
      
    }, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
  }
  
  print(paste0('iteration: ',iter))
  
  collective.scls[[iter+1]]=L_all
  if(temp>1){
    temp=temp*(1-coolrate)
  }
}

end.time <- Sys.time()
time.taken <- end.time - start.time
print(time.taken)



